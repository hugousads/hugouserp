<?php

declare(strict_types=1);

namespace Tests\Feature\Financial;

use App\Services\DiscountService;
use App\Services\PricingService;
use Illuminate\Foundation\Testing\RefreshDatabase;
use Tests\TestCase;

/**
 * Test for Discount Stacking Vulnerability Fix
 * 
 * Ensures that multiple discounts cannot be stacked to create
 * negative prices or exceed reasonable limits.
 */
class DiscountStackingVulnerabilityTest extends TestCase
{
    use RefreshDatabase;

    protected DiscountService $discountService;
    protected PricingService $pricingService;

    protected function setUp(): void
    {
        parent::setUp();
        
        $this->discountService = app(DiscountService::class);
        $this->pricingService = app(PricingService::class);
    }

    /** @test */
    public function it_prevents_negative_pricing_from_excessive_discounts()
    {
        // Scenario: Product price 100, applying multiple discounts that would go negative
        $line = [
            'qty' => 1,
            'price' => 100,
            'discount' => 150, // Trying to discount 150 on a 100 price item
            'percent' => false,
        ];

        $totals = $this->pricingService->lineTotals($line);

        $this->assertGreaterThanOrEqual(0, $totals['total'], 
            'Total price should never be negative');
        $this->assertEquals(0, $totals['total'], 
            'Total should be 0 when discount exceeds price');
    }

    /** @test */
    public function it_prevents_discount_exceeding_subtotal()
    {
        // Discount of 120% should be capped at 100% of subtotal
        $line = [
            'qty' => 2,
            'price' => 50,
            'discount' => 120, // 120% discount
            'percent' => true,
        ];

        $totals = $this->pricingService->lineTotals($line);

        $this->assertGreaterThanOrEqual(0, $totals['total']);
        $this->assertLessThanOrEqual($totals['subtotal'], $totals['discount'],
            'Discount should not exceed subtotal');
    }

    /** @test */
    public function it_validates_discount_stacking_rules()
    {
        $baseAmount = 1000;

        // Valid: Single customer discount
        $result = $this->discountService->validateDiscountStacking([
            ['type' => 'customer', 'value' => 20, 'is_percent' => true],
        ], $baseAmount);

        $this->assertTrue($result['allowed']);
        $this->assertEquals(200, $result['total_discount']); // 20% of 1000

        // Invalid: Coupon + Seasonal discount combination
        $result = $this->discountService->validateDiscountStacking([
            ['type' => 'coupon', 'value' => 50, 'is_percent' => false],
            ['type' => 'seasonal', 'value' => 30, 'is_percent' => true],
        ], $baseAmount);

        $this->assertFalse($result['allowed'], 
            'Should not allow coupon and seasonal discount together');
        $this->assertStringContainsString('Cannot combine', $result['reason']);
    }

    /** @test */
    public function it_enforces_maximum_combined_discount_percentage()
    {
        $baseAmount = 1000;

        // Trying to stack discounts that exceed 80% cap
        config(['sales.max_combined_discount_percent' => 80]);

        $result = $this->discountService->validateDiscountStacking([
            ['type' => 'customer', 'value' => 50, 'is_percent' => true], // 50%
            ['type' => 'volume', 'value' => 40, 'is_percent' => true],   // 40% on remaining
        ], $baseAmount);

        // 50% off = 500, remaining = 500
        // 40% off 500 = 200, total discount = 700 (70%)
        // This should be allowed since 70% < 80%
        $this->assertTrue($result['allowed']);

        // Now try excessive stacking
        $result = $this->discountService->validateDiscountStacking([
            ['type' => 'customer', 'value' => 50, 'is_percent' => true],
            ['type' => 'volume', 'value' => 50, 'is_percent' => true],
            ['type' => 'promotion', 'value' => 20, 'is_percent' => true],
        ], $baseAmount);

        // This would result in > 80% discount
        $this->assertFalse($result['allowed'], 
            'Should reject when combined discount exceeds maximum');
    }

    /** @test */
    public function it_calculates_sequential_discount_stacking_correctly()
    {
        $baseAmount = 1000;

        $result = $this->discountService->validateDiscountStacking([
            ['type' => 'customer', 'value' => 20, 'is_percent' => true],  // 20% off 1000 = 200, remaining 800
            ['type' => 'volume', 'value' => 100, 'is_percent' => false],  // 100 off 800 = remaining 700
        ], $baseAmount);

        $this->assertTrue($result['allowed']);
        $this->assertEquals(300, $result['total_discount']); // 200 + 100
        $this->assertEquals(700, $result['final_amount']); // 1000 - 300
    }

    /** @test */
    public function it_prevents_negative_final_amount_from_stacked_fixed_discounts()
    {
        $baseAmount = 100;

        // Stack fixed discounts that exceed base amount
        $result = $this->discountService->validateDiscountStacking([
            ['type' => 'coupon', 'value' => 50, 'is_percent' => false],
            ['type' => 'promotion', 'value' => 60, 'is_percent' => false],
        ], $baseAmount);

        // Even if allowed, final amount should be 0, not negative
        $this->assertGreaterThanOrEqual(0, $result['final_amount'] ?? 0,
            'Final amount should never be negative');
    }

    /** @test */
    public function it_handles_edge_case_of_100_percent_discount()
    {
        $line = [
            'qty' => 1,
            'price' => 100,
            'discount' => 100,
            'percent' => true,
        ];

        $totals = $this->pricingService->lineTotals($line);

        $this->assertEquals(0, $totals['total']);
        $this->assertEquals(100, $totals['discount']);
        $this->assertEquals(100, $totals['subtotal']);
    }

    /** @test */
    public function it_prevents_system_paying_customer_scenario()
    {
        // Real-world exploit scenario from bug report:
        // Product: 100
        // Customer discount 20%: 80
        // Seasonal 50%: 40  
        // Coupon 50 fixed: -10 (EXPLOIT!)

        $baseAmount = 100;

        // First, check if this combination is even allowed
        $validation = $this->discountService->validateDiscountStacking([
            ['type' => 'customer', 'value' => 20, 'is_percent' => true],
            ['type' => 'seasonal', 'value' => 50, 'is_percent' => true],
            ['type' => 'coupon', 'value' => 50, 'is_percent' => false],
        ], $baseAmount);

        // Should be blocked due to coupon + seasonal rule
        if ($validation['allowed']) {
            // If somehow allowed, ensure final amount is not negative
            $this->assertGreaterThanOrEqual(0, $validation['final_amount'],
                'System must never pay customer');
        }

        // Test through pricing service as well
        $line = [
            'qty' => 1,
            'price' => 100,
            'discount' => 90, // Extreme discount
            'percent' => false,
        ];

        $totals = $this->pricingService->lineTotals($line);
        
        $this->assertGreaterThanOrEqual(0, $totals['total'],
            'Price must be >= 0, system should never pay customer');
    }
}
